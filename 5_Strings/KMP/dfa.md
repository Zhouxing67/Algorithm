# KMP构造DFA的过程

==当前状态S~cur~ = S~k~ = k, (i < j < k)==

### DFA中的转化

S~next~的取值

- 当下个字符匹配时：S~next~ = S~k+1~ = k + 1;
- 不匹配时：回溯即S~next~ = S~pre~ (其中S~pre~的值由下一个不匹配的字符确定)

**我们关注的是当不匹配的是时候S~next~的取值**

### 注意到

**定理一**：**存在一个状态S~j~ 使得当S~j~的下一个字符不匹配时，S~j~的回溯状态与S~k~的回溯状态一致。**

记作：back_S~k~ <-- back_S~j~

那么有：back_S~k~ <-- back_S~j~ <-- back_S~i~ <-- ... <-- back_S~init~ == back_S~0~, 其中back_S~0~ == [0,...,0];

于是我们就可以根据S~init~构造出DFA矩阵

当我们求出了每一个状态的回溯状态back_S, 而匹配状态S~i~ = i已知， 进而求得整个DFA矩阵

即**仅仅通过S~init~便可以构造DFA**

### 定理一

关于定理一的证明思路：

**显式回退的暴力算法思路**：

当匹配到str[i] 与 pat[j] 时，当前的状态记作S~2~ , 若下一个字符即str[i + 1] != pat[j + 1],则i 需要显示回退到 i - j + 1的位置

现在考虑模式字串pat[0,... j]

1. 存在模式字串前缀pat[0,..., h] == 模式字串后缀pat[j - h,..., j]
2. 不存在

对于情况一：i在回退后一定会前进到i- j + 1 + h的位置，状态必然会转变为S~1~，

对于情况二：i在回退后一定会前进到i- j + 1的位置，状态必然会转变为S~0~ == S~init~

**现在既然kmp算法在匹配失败时，不会回退i,从而导致上述的状态转换不会发生，那么我们就要正确的设置S~2~的回溯状态，来假装回退了指针i, 使得对于情况一，若下一个字符不匹配，则S~2~的回溯状态必然要与S~1~的回溯状态一致，即back_S~2~ ==back_S~1~, 对于情况二，若下一个字符不匹配，S~2~的回溯状态必然要与S~0~的回溯状态一致， 即back_S~2~ == back_S~1~。**

上面一段话为kmp算法正确的必要条件， 即kmp算法正确，上述条件一定满足，而kmp算法无疑肯定是正确的，故上述条件一定是满足的，由此，可以根据上面的条件来构造dfa矩阵

### 参见《算法第四版》中关于KMP的描述

**中文版P493**